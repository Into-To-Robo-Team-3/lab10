#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//black is anything under 25
//blue is between 25 and 45
//white is over 45 
//Sonar distance for task 1 is 27

int white_border = 50; //playing field white border light value 

int detect_dist = 150; //distance to charge
int scan_motor_power = 60; //power to send to motor
int charge_motor_power = 75; //power to send to motor for charge
int reverse_motor_power = -60; //power to send to motor for reversing 
int measured_dist; //stores current ultrasonic distance reading 
int scan_direction = 1; //clockwise = 0, counterclockwise = 1; 
int charging = 0;

int reverse_wait_time = 300; // how long to spend reversing 

int readSonar(){
	return SensorValue[sonar];
}

int readLight(){
	return SensorValue[light];
}	

void pivot_clockwise(){
	charging = 0;
	while(readSonar() > detect_dist){
		motor[leftMotor] = scan_motor_power;
		motor[rightMotor] = -scan_motor_power;
		wait1Msec(100);
	}	
	scan_direction = 0; //now moving clockwise
}

void pivot_counterclockwise(){
	charging = 0;
	while(readSonar() > detect_dist){
		motor[leftMotor] = -scan_motor_power;
		motor[rightMotor] = scan_motor_power;
		wait1Msec(100);
	}	
	scan_direction = 1; //now moving counterclockwise
}

void charge(){ //charge as long locked is True 
	charging = 1;
	motor[leftMotor] = charge_motor_power;
	motor[rightMotor] = charge_motor_power;
	wait1Msec(150);
}	

void reverse(){ //move in reverse 
	charging = 0;
	motor[leftMotor] = reverse_motor_power;
	motor[rightMotor] = reverse_motor_power;
	wait1Msec(reverse_wait_time);
}	

void search_and_destroy(){
	measured_dist = readSonar();
	//nxtDisplayString(0,"%d", measured_dist);
	nxtDisplayString(1,"%d", readLight());
	if(readLight() >= white_border){ //detected playing field border
			reverse();
			//wait1Msec(reverse_wait_time); //back up for this duration 
	}
	else if(measured_dist > detect_dist){
		if(scan_direction == 0) //pivoted clockwise
			pivot_counterclockwise(); //now try counterclockwise
		else if(scan_direction == 1)  //pivoted counterclockwise
			pivot_clockwise(); //now try clockwise
	}
	else if(measured_dist <= detect_dist){
		wait1Msec(100);
		charge();
	}	
	//nxtDisplayClearTextLine(0);
}

task main()
{
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	while(true){
		search_and_destroy();
	}
} 
