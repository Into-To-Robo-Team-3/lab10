#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//black is anything under 25
//blue is between 25 and 45
//white is over 45 
//Sonar distance for task 1 is 27

int scan_motor_power = 40; //power to send to motor

int detect_dist = 45; //distance to charge
//int proximity_dist = 45; //distance to consider
int charge_motor_power = 50; //power to send to motor for charge
int measured_dist; //stores current ultrasonic distance reading 
int robotSpeed; //estimation of robot's speed (not actual speed)
int scan_direction = 1; //clockwise = 0, counterclockwise = 1; 
int charging = 0;

int readSonar(){
	return SensorValue[sonar];
}

int readLight(){
	return SensorValue[light];
}	

void pivot_clockwise(){
	while(readSonar() > detect_dist){
		motor[leftMotor] = scan_motor_power;
		motor[rightMotor] = -scan_motor_power;
		wait1Msec(100);
	}	
	scan_direction = 0; //now moving clockwise
}

void pivot_counterclockwise(){
	while(readSonar() > detect_dist){
		motor[leftMotor] = -scan_motor_power;
		motor[rightMotor] = scan_motor_power;
		wait1Msec(100);
	}	
	scan_direction = 1; //now moving counterclockwise
}

void charge(){ //charge as long locked is True 
	motor[leftMotor] = charge_motor_power;
	motor[rightMotor] = charge_motor_power;
	robot_charing = 1;
}	

void search_and_destroy(){
	measured_dist = readSonar();
	if(measured_dist > detect_dist){
		if(scan_direction == 0) //pivoted clockwise
			pivot_counterclockwise(); //now try counterclockwise
		else if(scan_direction == 1)  //pivoted counterclockwise
			pivot_clockwise(); //now try clockwise
	}
	else if(measured_dist <= detect_dist){
		wait1Msec(200);
		charge();
	}	
}


task main()
{
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	while(true){
		search_and_destroy();
	}	
} 
